import os # Provides functions for interacting with the operating system (file paths, existence checks, etc.)
import numpy as np # Used for numerical operations and handling image arrays
import cv2 # OpenCV library — used here to read and process image files
import matplotlib # Library for plotting and visualization (general module)
import matplotlib.pyplot as plt # Specific pyplot interface for displaying images and plots
import tensorflow as tf # Deep learning framework used for building and loading the neural network model

#The code below trains a neural network on the MNIST handwritten digits dataset

(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data() # Loads the MNIST dataset from TensorFlow — 60,000 training and 10,000 test images.
x_train = x_train.astype("float32") / 255.0
x_test  = x_test.astype("float32") / 255.0


model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)), # Flattens each 28×28 image into a 1D vector of 784 pixels.
    tf.keras.layers.Dense(128, activation='relu'), # First hidden layer with 128 neurons using ReLU activation
    tf.keras.layers.Dense(128, activation='relu'), # Second hidden layer with 128 neurons using ReLU activation.
     tf.keras.layers.Dense(10, activation='softmax') # Output layer: 10 neurons (for digits 0–9), softmax gives probabilities.
 ])

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy']) # Compiles the model: Adam optimizer + cross-entropy loss (for integer labels).
model.fit(x_train, y_train, epochs=6, validation_data=(x_test, y_test)) # Trains the model for 6 epochs and checks performance on test data each epoch.


model.save('handwritten.keras')   # saves the model

m2 = tf.keras.models.load_model('handwritten.keras') # loads previously saved model


image_number = 1 # stats with digit number 1
while os.path.isfile(f"digits/digit{image_number}.png"):  # Whiel there are more digits in the folder
  try:

    img = cv2.imread(f"digits/digit{image_number}.png")[:,:,0] # Reads the image
    img = np.invert(np.array([img])) # Processes the imgae by inverting colors and wraps it in another array
    prediction = m2.predict(img) # The model outputs a vector of 10 probability values (for digits 0–9).
    print(f"This digit is probably a {np.argmax(prediction)}") # np.argmax() finds the index (0–9) with the highest probability → the predicted digit.
    plt.imshow(img[0], cmap=plt.cm.binary) #Shows the image
    plt.show()
  except:
    print("Error!") #If there's an error print error
  finally:
    image_number += 1 # Increase the image number so the loop moves to the next file
